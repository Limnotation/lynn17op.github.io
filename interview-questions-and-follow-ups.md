## 计算机系统

### 从代码到机器码的各个阶段

以C语言为例，C语言编译主要分为四个阶段

1. 预处理

    此阶段主要完成#符号后面的各项内容到源文件的替换，往往一些莫名其妙的错误都是出现在头文件中的，要在工程中注意积累一些错误知识。

    - #ifdef等内容，完成条件编译内容的替换
    - #include中内容，在当前目录或者指定目录，或者默认目录搜索头文件，并将头文件拷贝到源文件中。
    - #define的内容，替换define的内容（包括上一步的头文件中的define内容）

    此阶段产生`[.i]`文件。

2.编译

 此阶段完成语法和语义分析，然后生成中间代码，此中间代码是汇编代码，但是还不可执行，`gcc`编译的中间文件是[.s]文件。

 在此阶段会出现各种语法和语义错误，特别要小心未定义的行为，这往往是致命的错误。

 第一个阶段和第二个阶段由编译器完成。

3.汇编

 此阶段主要完成将汇编代码翻译成机器码指令，并将这些指令打包形成可重定位的目标文件，[.O]文件，是		二进制文件。

 此阶段由汇编器完成。

4.链接

 此阶段完成文件中叼用的各种函数跟静态库和动态库的连接，并将它们一起打包合并形成目标文件，即可执行文件。

 此阶段由链接器完成。

 `gcc`编译C语言主要用到以下几个程序：C编译器`gcc`、汇编器as、链接器`ld`和二进制转换工具`objcopy`。

### 并发并行

### 同步异步

### 阻塞非阻塞

-----

## 计算机网络

### TCP

#### TIME_WAIT出现在哪个阶段，并发量大的情况下TIME_WAIT同时大量存在有什么措施？

① 出现在主动关闭连接方的最后一个阶段，在收到对方的FIN码以及自己发送ACK码后。TIME_WAIT大量存在造成端口号不足使得建立其他新连接失败。

②措施: 

​	 第一是降低TIME_WAIT的等待时间

​	第二是设置处于TIME_WAIT的端口可重用

具体分析参考:https://blog.csdn.net/zl1zl2zl3/article/details/107676367

#### 如果两边同时关闭连接会怎么样，状态怎么变？

- 正常情况下，当客户端发送FIN报文后，应该会先收到(或同时收到)对方的ACK报文，再收到对方的FIN报文。但是如果两边同时关闭连接则会先收到对方的FIN报文
- 此时客户端会由FIN_WAIT_1状态直接进入CLOSING状态

------

## 操作系统

### 内存

####  操作系统为什么要设置虚拟内存，主要用于解决什么问题？

1. 虚拟内存可以结合磁盘和物理内存的优势为进程提供看起来速度足够快并且容量足够大的存储，它把主存看作一个存储在硬盘上的虚拟地址空间的高速缓存，并且只在主存中缓存活动区域（按需缓存）
2. 它为每个进程提供了一个一致的地址空间，从而降低内存管理的复杂性
3. 它保护了每个进程的地址空间不被其他进程破坏

-----

### 进程

#### copy-on-write

写入时复制（英语：Copy-on-write，简称COW）是一种计算机[程序设计](https://wikipedia.hk.wjbk.site/baike-程式設計)领域的优化策略。其核心思想是: 如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源

#### 为什么进程进行上下文切换比线程上下文切换代价高？

进程切换分两步：

- 切换页目录以使用新的地址空间

- 切换内核栈和硬件上下文

    对于linux来说，线程和进程的最大区别就在于地址空间，对于线程切换，第1步是不需要做的，第2是进程和线程切换都要做的。

切换的性能消耗：

- 线程上下文切换和进程上下文切换一个最主要的区别是**线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的**。这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出。
- 另外一个隐藏的损耗是**上下文的切换会扰乱处理器的缓存机制**。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲（processor's Translation Lookaside Buffer (TLB)）或者相当的神马东西会被全部刷新，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题

----

## Linux

### linux查看进程怎么看？

- ps: 查看某个时间点的进程信息

    > ​	ps -l : 进查看自己的bash相关进程
    >
    > ​	ps aux: 查看系统所有进程

- top: 动态查看进程的变化
- pstree: 查看进程树

参考：《鸟哥私房菜》p524

-----

## mysql

### mysql如何解除死锁

```mysql
解除正在死锁的状态有两种方法：

第一种：
	1.查询是否锁表
	  show OPEN TABLES where In_use > 0;
	2.查询进程（如果您有SUPER权限，您可以看到所有线程。否则，您只能看到您自己的线程）
	  show processlist
	3.杀死进程id（就是上面命令的id列）
	  kill id
	  
第二种：
	1.查看下在锁的事务 
	  SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;
	2.杀死进程id（就是上面命令的trx_mysql_thread_id列）
	  kill 线程ID

其它关于查看死锁的命令：
    1：查看当前的事务
      SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;

    2：查看当前锁定的事务
      SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;

    3：查看当前等锁的事务
      SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;
```



------

## Redis

### redis持久化有哪几种方式

- RDB：将某一时刻的数据库状态全量保存到二进制格式文件中

    ​		特点：文件体积小，恢复速度快；由于需要遍历数据库，存在时效性和停机风险

- AOF：将所有修改数据库的写命令以协议文本格式存储

    ​		特点：数据丢失的时间窗口小；文件体积较大，恢复速度较慢

- RDB-AOF混合持久化：基于AOF持久化模式构建，发生在AOF重写过程中

    ​		特点：1、重写后的AOF文件前半部分是RDB格式的全量数据，后半段是AOF格式的增量数据

    ​				   2、混合持久化的优势在于通过RDB实现数据快速恢复，同时通过AOF控制数据丢失的时间在1s之内

### redis主从同步（复制）是怎样的过程？

1. 使用 SLAVEOF命令或设置slaveof选项可以进行主从同步
2. 主从同步分为同步和命令传播两个步骤
    - 同步：将从服务器的数据库状态更新成主服务器当前的数据库状态
    - 命令传播：当主服务器数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的过程
3. 主从同步过程分为初次复制和断线后复制两种情况

参考：https://www.jb51.net/article/156147.htm



-----

## kafka

### kafka选主是怎么做的

- 参考：https://www.cnblogs.com/tonggc1668/p/12051030.html

### **kafka** 分区怎么同步的

- kafka的分区存在多副本机制，有leader和follower两种角色；
- leader负责与生产者和消费者交互，follower会从leader拉取消息实现与leader的同步

-----

## 分布式

### raft算法和paxos算法

- 参考：《从paxos到zookeeper》、http://blog.itpub.net/31556438/viewspace-2637112/

----

## 数据结构与算法

### 字符串至少删除多少个字符能构成回文串