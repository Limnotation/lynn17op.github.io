- [1、进程](#1进程)
  - [1.1、进程间通信方式](#11进程间通信方式)
    - [1.1.1 管道](#111-管道)
      - [创建管道](#创建管道)
      - [管道的实质：](#管道的实质)
      - [管道的同步](#管道的同步)
      - [管道的局限](#管道的局限)
    - [1.1.2 命名管道](#112-命名管道)
    - [1.1.3 信号](#113-信号)
    - [1.1.4 信号量](#114-信号量)
    - [1.1.5 共享内存](#115-共享内存)
    - [1.1.6 消息队列](#116-消息队列)
    - [1.1.7 套接字](#117-套接字)
- [2、IO](#2io)
  - [2.1 IO多路复用](#21-io多路复用)
    - [2.1.1 select](#211-select)## 1、进程

### 1.1、进程间通信方式

进程间一共有7中主流的通信方式

- 信号
- 管道
- 命名管道
- 信号量
- 共享内存
- 消息队列
- 套接字

|   方式   |    传输的信息量    |         使用场景         |                            关键词                            |
| :------: | :----------------: | :----------------------: | :----------------------------------------------------------: |
|   信号   |        少量        |        任何进程间        |                   硬件、软件来源/信号队列                    |
|   管道   |        大量        |        亲缘进程间        | 单向流动/内核缓冲区/循环队列/没有格式的字节流/操作系统负责同步 |
| 命名管道 |        大量        |        任何进程间        |    磁盘文件/访问权限/无数据块/内核缓冲区/操作系统负责同步    |
|  信号量  |         0          |        任何进程间        |                    互斥同步/原子性/P减V增                    |
| 共享内存 |        大量        |        多个进程间        |             内存映射/简单快速/操作系统不保证同步             |
| 消息队列 | 比信号多，但有限制 |        任何进程间        |            有格式/按消息类型过滤/操作系统负责同步            |
|  套接字  |        大量        | 不同或相同主机下的进程间 |              读缓冲区/写缓冲区/操作系统负责同步              |

------

#### 1.1.1 管道

管道命令，在linux shell中经常使用。一般使用管道操作符 `|`来表示两个命令之间的数据通信。如：

```shell
ps -ef | grep java | xargs echo
```

管道操作符的内部实现其实就是Linux的管道接口。由管道操作符 `|`分割的每个命令是独立的进程，前一个进程的标准输出STDOUT,会作为下一个进程的标准输入STDIN

- 管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。
- 只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);
- 单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。
- 数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据

![img](../../../../mdPics/1281379-05378521a7b41af4.png)

##### 创建管道

通过 `pipe()`系统调用来创建并打开一个管道，当最后一个使用它的进程关闭对它的引用时，pipe将自动撤销

通过 `pipe()`创建的是匿名管道，只能用于具有亲缘关系的进程之间（父子进程或兄弟进程）

##### 管道的实质：

- 管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。
- 该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。
- 当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。

##### 管道的同步

管道是一个具有特定大小的缓冲区

- 操作系统保证读写进程的同步
- 上游进程或者下游进程需要等另一方释放锁后才能操作管道。管道就相当于一个文件，同一时刻只能有一个进程访问
- 当管道为空时，下游进程读阻塞；当管道满时，上游进程写阻塞
- 管道不再被任何进程使用时，自动撤销

##### 管道的局限

- 只支持单向数据流；

- 只能用于具有亲缘关系的进程之间；

- 没有名字；

- 管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）；

- 管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等

-----

#### 1.1.2 命名管道

- 命名管道（FIFO）可用于没有亲缘的进程间。Pipe和FIFO除了建立、打开、删除的方式不同外，二者几乎一模一样。有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，**以有名管道的文件形式存在于文件系统中**，这样，**即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信**，因此，通过有名管道不相关的进程也能交换数据

- 通过 `mknode()`系统调用或者 `mkfifo()`函数建立命名管道。一旦建立，任何有访问权的进程都可以通过文件名将其打开和进行读写。

- 建立命名管道时，会在磁盘中建立一个索引节点，命名管道的名字就相当于索引节点的文件名。索引节点设置了进程的访问权限，但是没有数据块。命名管道实质上也是通过 **内核缓冲区**来实现数据传输。有访问权限的进程，可以通过磁盘的索引节点来读写这块缓冲区。

- 当不再被任何进程使用时，命名管道在内存中释放，但磁盘节点仍然存在。

> 匿名管道和有名管道的总结：
>
> （1）管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。
>  （2）匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。
>  （3）**无名管道阻塞问题：**无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。
>  （4）**有名管道阻塞问题：**有名管道在打开时需要确定对方的存在，否则将阻塞。即当前进程以读方式打开某管道，在此之前必须有另一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。

----

#### 1.1.3 信号

信号是Linux系统响应某些条件而产生的一个事件。由操作系统事先定义，接收到该信号的进程可以采取自定义的行为。这是一种“订阅-发布”的模式

信号来源分为硬件来源和软件来源：

1. 硬件来源：如CTRL+C、除0、非法内存访问等
2. 软件来源：如kill命令、Alarm Clock超时、当Reader中止之后又向管道写数据等

一般的信号是都是由一个错误产生的。以除 0 为例。在 x86 机器上 DIV 或 IDIV 指令除数为 0 时，会引发 0 号中断，编号 #DE(Divide Error)，即所谓除零异常。这是一个硬件级中断，会导致陷入内核，执行操作系统预定义在 IDT 中的中断处理程序。而操作系统处理这个异常的方法，就是**向进程发送一个信号 `SIGFPE`**。如果进程设置了相应的 signal handler，就执行进程的处理方法。否则，执行操作系统的默认操作，一般这种信号的默认操作是杀死进程。

同理，溢出、非法内存访问（越界）、非法指令等也都属于硬件中断，由操作系统处理。**操作系统会将这些硬件异常包装成“信号”发送给进程**。如果进程不处理这几个异常信号，那么默认的行为就是挂掉。

信号也可以作为进程间通信的一种方式，明确地由一个进程发送给另一个进程

**进程发送信号：**

- 操作系统提供发送信号的系统调用
- 该系统调用会将信号放到目标进程的信号队列中
- 如果目标进程未处于执行状态，信号由内核保存，直到该进程恢复执行并将信号传递给它为止；如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程
- 发送信号时，必须指明发送目标进程的进程号，所以信号一般用在具有亲缘关系的进程之间

**进程接收信号：**

- 每个进程有一个信号队列，放其他进程发给它、等待被它处理的信号
- 进程在执行过程中的特定时刻，检查并处理自己的信号队列。比如从系统空间返回到用户空间之前。

**进程对信号的处理：**

1. 处理信号：定义信号处理函数，当信号产生时，执行相应的处理函数
2. 忽略信号：当不希望接收到的信号对进程的执行产生影响，可以忽略该信号
3. 不处理也不忽略：执行默认操作，Linux对每种信号都定义了默认操作

-----

#### 1.1.4 信号量

信号量是一种特殊的变量，对它的操作都是原子的，有两种操作：V(`signal()`)和P(`wait()`)。V操作会增加信号标S的数值，P操作会减少它

- V(S):如果有其他进程因为等待S而被挂起，就让它恢复运行，否则S加1
- P(S):如果S为0，则挂起进程，否则S减1

如果信号量是一个任意的整数，通常称为计数信号量（counting semaphore）,或一般信号量(general semaphore);如果信号量只有二进制的0或1，称为二进制信号量（binary semaphore）。在linux系统中，二进制信号量又称互斥锁（Mutex）.

-----

#### 1.1.5 共享内存

共享内存顾名思义，允许两个或多个进程共享同一段物理内存。**不同进程可以将同一段共享内存映射到自己的地址空间，然后像访问正常内存一样访问它**。不同进程可以通过向共享内存端读写数据来交换信息。**是最快的可用IPC形式**

一个进程可以通过操作系统的系统调用，创建一块共享内存区；其他进程通过系统调用把这段内存映射到自己的用户地址空间中；之后各个进程向读写正常内存一样，读写共享内存。共享内存区只会驻留在创建它的进程地址空间内。

**共享内存的优点是简单且高效**，访问共享内存区域和访问进程独有的内存区域一样**快**，原因是不需要系统调用，不涉及用户态到内核态的转换，也不需要对数据不必要的复制。

比如管道和消息队列，需要在内核和用户空间进行四次的数据拷贝（读输入文件、写到管道；读管道、写到输出文件），而共享内存则只拷贝两次：一次从输入文件到共享内存区，另一次从共享内存到输出文件（[图示](https://cloud.tencent.com/developer/article/1021157)）。此外，消息传递的实现经常采用系统调用，也就经常需要用户态和内核态互相转换；而共享内存只在建立共享内存区域时需要系统调用；一旦建立共享内存，所有访问都可作为常规内存访问，无需借助内核。

**共享内存的缺点是存在并发问题**，有可能出现多个进程修改同一块内存，因此共享内存一般与信号量结合使用.

-----

#### 1.1.6 消息队列

- **消息队列是一个消息的链表**，保存在内核中。消息队列中的每个消息都是一个**数据块**，具有特定的格式。操作系统中可以存在多个消息队列，每个消息队列有唯一的 **key**，称为消息队列标识符。

- 消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。和信号相比，消息队列能够传递更多的信息。与管道相比，消息队列提供了**有格式**的数据，但消息队列仍然有大小限制。

- 消息队列允许一个或多个进程向它写入与读取消息。消息的发送者和接收者不需要同时与消息队列交互。消息会保存在队列中，直到接收者取回它。也就是说，消息队列是**异步**的，但这也造成了一个缺点，就是接收者必须**轮询**消息队列，才能收到最近的消息。

- 操作系统提供创建消息队列、取消息、发消息等系统调用。

- 操作系统负责读写同步：若消息队列已满，则写消息进程排队等待；若取消息进程没有找到需要的消息，则在等待队列中寻找。

- 消息队列和管道相比，相同点在于二者都是通过发送-接收的方式进行通信，并且数据都有最大长度限制。不同点在于消息队列的数据是有格式的，并且**取消息进程可以选择接收特定类型的消息**，而不是像管道中那样默认全部接收。
- 与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除

----

#### 1.1.7 套接字

- 不同的计算机的进程之间通过 socket 通信，*也可用于同一台计算机的不同进程*
- 需要通信的进程之间首先要各自创建一个 socket，**内容包括主机地址与端口号**，声明自己接收来自某端口地址的数据
- 进程通过 socket 把消息发送到网络层中，网络层通过主机地址将其发到目的主机，目的主机通过端口号发给对应进程

操作系统提供创建 socket、发送、接收的系统调用，为每个 socket 设置发送缓冲区、接收缓冲区。

------

-------

------

## 2、IO

### 2.1 IO多路复用

进程可以通过select、poll、epoll发起I/O多路复用的系统调用，这些系统调用都是同步阻塞的：**如果传入的多个文件描述符中，有描述符就绪，则返回就绪的描述符；否则如果所有文件描述符都未就绪，就阻塞调用进程，直到某个描述符就绪，或者阻塞时长超过设置的timeout后返回。**

I/O 多路复用引入了一些额外的操作和开销，性能更差。但是好处是用户可以在一个线程内同时处理多个 I/O 请求。如果不采用 I/O 多路复用，则必须通过多线程的方式，每个线程处理一个 I/O 请求。后者线程切换也是有一定的开销的。

-------

#### 2.1.1 select

- 函数签名与参数

    ```c
    int select(int nfds,
              fd_set *restrict readfds,
              fd_set *restrict writefds,
              fd_set *restrict errorfds,
              struct timeval *restrict timeout);
    ```

    1. `readfds`、`writefds` 、`errorfds`是三个文件描述符集合。`select`会遍历每个集合的前 `nfds`个描述符，分别找到可以读、可以写、发生错误的描述符，这些描述符统称为 `就绪`的描述符
    2. `timeout`参数表示调用 `select`时的阻塞时长。如果所有文件描述符都未就绪，就阻塞调用进程，直到某个描述符就绪，或者阻塞超过设置的 timeout 后，返回。如果 `timeout` 参数设为 NULL，会无限阻塞直到某个描述符就绪；如果 `timeout` 参数设为 0，会立即返回，不阻塞

- 关于fd_set文件描述符集合

    参数中的 `fd_set` 类型表示文件描述符的集合。

    由于文件描述符 `fd` 是一个从 0 开始的无符号整数，所以可以使用 `fd_set` 的**二进制每一位**来表示一个文件描述符。某一位为 1，表示对应的文件描述符已就绪。比如比如设 `fd_set` 长度为 1 字节，则一个 `fd_set` 变量最大可以表示 8 个文件描述符。当 `select` 返回 `fd_set = 00010011` 时，表示文件描述符 `1`、`2`、`5` 已经就绪。

    `fd_set` 的使用涉及以下几个 API：

    ```c
    #include <sys/select.h>   
    int FD_ZERO(int fd, fd_set *fdset);  // 将 fd_set 所有位置 0
    int FD_CLR(int fd, fd_set *fdset);   // 将 fd_set 某一位置 0
    int FD_SET(int fd, fd_set *fd_set);  // 将 fd_set 某一位置 1
    int FD_ISSET(int fd, fd_set *fdset); // 检测 fd_set 某一位是否为 1
    ```

- select使用示例

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <sys/time.h>
    #include <sys/types.h>
    #include <unist.h>
    
    int main(void) {
        // open and set up a bunch of sockets(not shown)
        // main loop
        while (1) {
            // initialize the fd_set to all zero
            fd_set readFDs;
            FD_ZERO(&readFDs);
            
            // now set the bits for the descriptors
            // this server is interested in
            // (for simplicity, all of them from min to max)
            int fd;
            for(fd = minFD; fd < maxFD; fd++)
                FD_SET(fd, &readFDs);
            
            // do the select
            int rc = select(maxFD + 1, &readFDs, NULL, NULL, NULL);
            
            // check which actually have data using FD_ISSET()
            int fd;
            for(fd = minFD; fd < maxFD; fd++)
                if(FD_ISSET(fd, &readFDs))
                    processFD(fd);
            
        }
    }
    ```

    代码流程说明：

    1. 先声明一个 `fd_set` 类型的变量 `readFDs`
    2. 调用 `FD_ZERO`，将 `readFDs` 所有位置 0
    3. 调用 `FD_SET`，将 `readFDs` 感兴趣的位置 1，表示要监听这几个文件描述符
    4. 将 `readFDs` 传给 `select`，调用 `select`
    5. `select` 会将 `readFDs` 中就绪的位置 1，未就绪的位置 0，返回就绪的文件描述符的数量
    6. 当 `select` 返回后，调用 `FD_ISSET` 检测给定位是否为 1，表示对应文件描述符是否就绪

    比如想监听1、2、5这三个文件描述符，就将 `readFDs`设置为 `00010011`，然后调用 `select`.

    如果 `fd=1`、`fd=2`就绪而 `fd=5`未就绪，select会将 `readFDs`设置为 `00000011`并返回2

    如果每个文件描述符都未就绪， `select`会阻塞 `timeout`时长再返回。这期间，如果 `readFDs` 监听的某个文件描述符上发生可读事件，则 `select` 会将对应位置 1，并立即返回