## 1、进程

### 1.1、进程间通信方式

进程间一共有7中主流的通信方式

- 信号
- 管道
- 命名管道
- 信号量
- 共享内存
- 消息队列
- 套接字

|   方式   |    传输的信息量    |         使用场景         |                            关键词                            |
| :------: | :----------------: | :----------------------: | :----------------------------------------------------------: |
|   信号   |        少量        |        任何进程间        |                   硬件、软件来源/信号队列                    |
|   管道   |        大量        |        亲缘进程间        | 单向流动/内核缓冲区/循环队列/没有格式的字节流/操作系统负责同步 |
| 命名管道 |        大量        |        任何进程间        |    磁盘文件/访问权限/无数据块/内核缓冲区/操作系统负责同步    |
|  信号量  |         0          |        任何进程间        |                    互斥同步/原子性/P减V增                    |
| 共享内存 |        大量        |        多个进程间        |             内存映射/简单快速/操作系统不保证同步             |
| 消息队列 | 比信号多，但有限制 |        任何进程间        |            有格式/按消息类型过滤/操作系统负责同步            |
|  套接字  |        大量        | 不同或相同主机下的进程间 |              读缓冲区/写缓冲区/操作系统负责同步              |

------

#### 1.1.1 管道

管道命令，在linux shell中经常使用。一般使用管道操作符 `|`来表示两个命令之间的数据通信。如：

```shell
ps -ef | grep java | xargs echo
```

管道操作符的内部实现其实就是Linux的管道接口。由管道操作符 `|`分割的每个命令是独立的进程，前一个进程的标准输出STDOUT,会作为下一个进程的标准输入STDIN

##### 定义

管道是一种半双工的通信方式，数据只能 **单向流动**，上游进程往管道中写入数据，下游进程从管道中接收数据。如果想实现双方通信，需要建立两个管道

管道适合于**传输大量信息**，其发送的内容是以字节为单位的，没有格式的字节流

##### 创建管道

通过 `pipe()`系统调用来创建并打开一个管道，当最后一个使用它的进程关闭对它的引用时，pipe将自动撤销

通过 `pipe()`创建的是匿名管道，只能用于具有亲缘关系的进程之间（父子进程或兄弟进程）

##### 管道的实现

**管道就是一个文件**，是一种只存在于内存中的特殊的文件系统

管道是由内核管理的一个缓冲区，缓冲区被设计成一个环形的数据结构，以便管道可以被循环利用（循环队列）

在linux中，管道借助了文件系统的File结构实现。父进程使用File结构保存向管道写入数据的例程地址，子进程保存从管道中读出数据的例程地址。这也造就了管道的两个特点：

1. 数据单向流动
2. 只能用于具有亲缘关系的进程之间

##### 管道的同步

管道是一个具有特定大小的缓冲区

- 操作系统保证读写进程的同步
- 上游进程或者下游进程需要等另一方释放锁后才能操作管道。管道就相当于一个文件，同一时刻只能有一个进程访问
- 当管道为空时，上游进程读阻塞；当

-----

#### 1.1.2 命名管道

----

#### 1.1.3 信号

信号是Linux系统响应某些条件而产生的一个事件。由操作系统事先定义，接收到该信号的进程可以采取自定义的行为。这是一种“订阅-发布”的模式

信号来源分为硬件来源和软件来源：

1. 硬件来源：如CTRL+C、除0、非法内存访问等
2. 软件来源：如kill命令、Alarm Clock超时、当Reader中止之后又向管道写数据等

一般的信号是都是由一个错误产生的。以除 0 为例。在 x86 机器上 DIV 或 IDIV 指令除数为 0 时，会引发 0 号中断，编号 #DE(Divide Error)，即所谓除零异常。这是一个硬件级中断，会导致陷入内核，执行操作系统预定义在 IDT 中的中断处理程序。而操作系统处理这个异常的方法，就是**向进程发送一个信号 `SIGFPE`**。如果进程设置了相应的 signal handler，就执行进程的处理方法。否则，执行操作系统的默认操作，一般这种信号的默认操作是杀死进程。

同理，溢出、非法内存访问（越界）、非法指令等也都属于硬件中断，由操作系统处理。**操作系统会将这些硬件异常包装成“信号”发送给进程**。如果进程不处理这几个异常信号，那么默认的行为就是挂掉。

信号也可以作为进程间通信的一种方式，明确地由一个进程发送给另一个进程

**进程发送信号：**

- 操作系统提供发送信号的系统调用
- 该系统调用会将信号放到目标进程的信号队列中
- 如果目标进程未处于执行状态，信号由内核保存，直到该进程恢复执行并将信号传递给它为止；如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程
- 发送信号时，必须指明发送目标进程的进程号，所以信号一般用在具有亲缘关系的进程之间

**进程接收信号：**

- 每个进程有一个信号队列，放其他进程发给它、等待被它处理的信号
- 进程在执行过程中的特定时刻，检查并处理自己的信号队列。比如从系统空间返回到用户空间之前。

**进程对信号的处理：**

1. 处理信号：定义信号处理函数，当信号产生时，执行相应的处理函数
2. 忽略信号：当不希望接收到的信号对进程的执行产生影响，可以忽略该信号
3. 不处理也不忽略：执行默认操作，Linux对每种信号都定义了默认操作

-----

#### 1.1.4 信号量

#### 1.1.5 共享内存

#### 1.1.6 消息队列

#### 1.1.7 套接字

