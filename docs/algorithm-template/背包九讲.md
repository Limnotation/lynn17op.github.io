## 1、 01背包问题

### 1.1 题目

有`N`件物品和一个容量为`V`的背包。放入第`i`件物品耗费的费用为  W<sub> i</sub> ,得到的价值为V<sub>i</sub>.求解将哪些物品装入背包可使价值总和最大。

### 1.2 基本思路

这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或者不放

用子问题定义状态：即`F[i, v]`表示只从前`i`件物品中选择，放入容量为`v`背包中可以获得的最大值。状态转移方程可以写成:
$$
F[i, v] = max\{F[i-1, v], F[i-1, v-W_i] + V_i\}
$$
对上述方程的解释：考虑“将前`i`件物品放入容量为`v`的背包中”这样一个子问题，若只考虑第 `i`件物品的策略(放或不放)，那么就可以转化为一个只和前`i-1`件物品相关的问题。有如下两种可能性：

1. 如果不放第`i`件物品，那么问题就转化为“前`i-1`件物品放入容量为v的背包中”这样一个子问题，此时的结果为`F[i-1, v]`
2. 如果放第`i`件物品，那么问题就转化为“前`i-1`个物品放入剩下的容量为`v` - `W`<sub>i</sub> 的背包中”，此时能获得的最大价值是`F[i-1, v` - `W`<sub>i</sub>`] + V`<sub>i</sub>.

相关的代码逻辑如下：

```java
public static void main(String[] args) {
    Scanner in = new Scanner(System.in);
    // N表示物品的数量
    int N = in.nextInt();
    // V表示背包的容量
    int V = in.nextInt();
    // weights[i]表示第i个物品所占的体积
    int[] weights = new int[N + 1];
    // values[i]表示选择第i个物品可以获得的价值
    int[] values = new int[N + 1];
    for(int i = 1; i <= N; i++) {
        weights[i] = in.nextInt();
        values[i] = in.nextInt();
    }

    // dp[i][j]表示在背包容量为j的情况下，在前i个物品中选择，可以得到的最大价值
    // dp[0][0...V] = 0，表示在没有物品可选择时，可得到的最大价值总是为0
    // dp[0...N][0] = 0，表示在背包空间为0的情况下不可能选择任何物品，所以可得到的价值也为0
    int[][] dp = new int[N+1][V+1];
    for(int i = 1; i <= N; i++) {
        for(int j = 1; j <= V; j++) {
            if(j < weights[i]) {
                dp[i][j] = dp[i-1][j];
            } else {
                dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j - weights[i]] + values[i]);
            }
        }
    }
    System.out.print(dp[N][V]);
}
```

### 1.3 优化空间复杂度

原解法的时间和空间复杂度为O(VN)

根据递推方程可知，`F[i, v]`由子问题 `F[i-1, v]`和`F[i-1, v - W`<sub>i</sub>`]`两个子问题递推而来。所以在计算`dp`矩阵的某一行时，所需要的仅仅是当前行上一行的两个位置的值，所以可以使用一个一维数组来代替二维数组。即`dp[N + 1][V + 1]` -> `dp[V + 1]`

相关的代码逻辑如下：

```java
public static void main(String[] args) {
    Scanner in = new Scanner(System.in);
    // N表示物品的数量
    int N = in.nextInt();
    // V表示背包的容量
    int V = in.nextInt();
    // weights[i]表示第i个物品所占的体积
    int[] weights = new int[N + 1];
    // values[i]表示选择第i个物品可以获得的价值
    int[] values = new int[N + 1];
    for(int i = 1; i <= N; i++) {
        weights[i] = in.nextInt();
        values[i] = in.nextInt();
    }

    // 在遍历到第i个物品时，dp[i]的值表示当前从前i个物品中选出的
    // 可以放入背包中的最大价值
    int[] dp = new int[V+1];
    for(int i = 1; i <= N; i++) {
        // 注意这里遍历背包容量时一定要倒序(原理还有待学习)
        for(int j = V; j >= weights[i]; j--) {
            dp[j] = Math.max(dp[j], dp[j - weights[i]] + values[i]);
        }
    }
    System.out.print(dp[V]);
}
```

### 1.4 初始化的细节问题

在求最优解的背包问题中，有两种不同类型的题目。有一类题目要求“恰好装满背包”时的最优解，另一类则不强制要求把背包装满。两类问题在初始化`dp`矩阵的时候有不同的要求。

如果要求**恰好装满背包**，则初始化时除了`dp[0] = 0`,其他的`dp[1...V]`均设为 - $\infty$ , 

如果不需要装满背包，只希望获得尽量大的价值，则将`dp[0...V]`均设为`0`

可以这样理解这个问题：将`dp`矩阵初始化就是设置在没有选取任何物品时背包的合法状态。在要求背包恰好被装满时，只有容量为0的背包可以在什么也不装且价值为0的情况下被“恰好装满”(`dp[0] = 0`，是唯一的合法解)，其他容量的背包由于没有装入任何物品所以是不存在一个合法解的，属于一个未定义的状态，所以应该设为-$\infty$ .如果背包并非必须被装满，那么任何容量的背包都有一个合法解：什么都不装，此时的价值为0(`dp[0...V] = 0`)

------

## 2、 完全背包问题

### 2.1 题目

有N件物品和一个容量为V的背包，每种物品都有无限件可用。放入第i件物品的